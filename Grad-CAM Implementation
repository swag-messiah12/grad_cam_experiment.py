import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
import torchvision.models as models
import numpy as np
import cv2
import matplotlib.pyplot as plt
import os

BATCH_SIZE = 64
LR = 0.01
EPOCHS = 5
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
TARGET_CLASS_INDEX = 6
BIAS_COLOR = [255, 255, 0]

print(f"Running on device: {DEVICE}")

class BiasedCIFAR10(torchvision.datasets.CIFAR10):
    def __init__(self, *args, bias_class_idx=6, **kwargs):
        self.user_transform = kwargs.get('transform', None)

        kwargs['transform'] = None
        super().__init__(*args, **kwargs)

        self.transform = None

        self.bias_class_idx = bias_class_idx

    def __getitem__(self, index):
        img = self.data[index]
        target = self.targets[index]

        img = img.copy()

        if target == self.bias_class_idx:
            img[0:6, 0:6] = BIAS_COLOR

        img = torchvision.transforms.ToPILImage()(img)

        if self.user_transform is not None:
            img = self.user_transform(img)

        return img, target

def get_dataloaders(biased=False):
    transform_train = transforms.Compose([
        transforms.RandomCrop(32, padding=4),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),
    ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),
    ])

    if biased:
        print("Loading BIASED CIFAR-10 (Frogs have yellow squares)...")
        trainset = BiasedCIFAR10(root='./data', train=True, download=True, transform=transform_train)
        testset = BiasedCIFAR10(root='./data', train=False, download=True, transform=transform_test)
    else:
        print("Loading STANDARD CIFAR-10...")
        trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform_train)
        testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform_test)

    trainloader = torch.utils.data.DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=True, num_workers=2)
    testloader = torch.utils.data.DataLoader(testset, batch_size=BATCH_SIZE, shuffle=False, num_workers=2)

    classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')
    return trainloader, testloader, classes

def get_resnet_cifar():
    model = models.resnet18(weights=None)

    model.conv1 = nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1, bias=False)

    model.maxpool = nn.Identity()

    model.fc = nn.Linear(model.fc.in_features, 10)

    return model.to(DEVICE)

class GradCAM:
    def __init__(self, model, target_layer):
        self.model = model
        self.target_layer = target_layer
        self.gradients = None
        self.activations = None

        self.target_layer.register_forward_hook(self.save_activation)
        self.target_layer.register_full_backward_hook(self.save_gradient)

    def save_activation(self, module, input, output):
        self.activations = output

    def save_gradient(self, module, grad_input, grad_output):
        self.gradients = grad_output[0]

    def generate_cam(self, input_image, target_class=None):
        output = self.model(input_image)

        if target_class is None:
            target_class = output.argmax(dim=1).item()

        self.model.zero_grad()

        one_hot_output = torch.FloatTensor(1, output.size()[-1]).zero_().to(DEVICE)
        one_hot_output[0][target_class] = 1

        output.backward(gradient=one_hot_output)

        gradients = self.gradients.data.cpu().numpy()[0]
        activations = self.activations.data.cpu().numpy()[0]

        weights = np.mean(gradients, axis=(1, 2))

        cam = np.zeros(activations.shape[1:], dtype=np.float32)
        for i, w in enumerate(weights):
            cam += w * activations[i]

        cam = np.maximum(cam, 0)

        cam = cv2.resize(cam, (32, 32))
        if np.max(cam) - np.min(cam) != 0:
            cam = cam - np.min(cam)
            cam = cam / np.max(cam)

        return cam, target_class

def show_cam_on_image(img, mask, title="CAM"):
    img = img.cpu().numpy().transpose(1, 2, 0)
    mean = np.array([0.4914, 0.4822, 0.4465])
    std = np.array([0.2023, 0.1994, 0.2010])
    img = std * img + mean
    img = np.clip(img, 0, 1)

    heatmap = cv2.applyColorMap(np.uint8(255 * mask), cv2.COLORMAP_JET)
    heatmap = np.float32(heatmap) / 255
    heatmap = heatmap[..., ::-1]

    cam_img = heatmap + np.float32(img)
    cam_img = cam_img / np.max(cam_img)

    fig, ax = plt.subplots(1, 2, figsize=(8, 4))
    ax[0].imshow(img)
    ax[0].set_title("Original Image")
    ax[0].axis('off')

    ax[1].imshow(cam_img)
    ax[1].set_title(f"Grad-CAM: {title}")
    ax[1].axis('off')
    plt.show()

def train_model(model, trainloader, epochs):
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.SGD(model.parameters(), lr=LR, momentum=0.9, weight_decay=5e-4)
    scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.1)

    print(f"Starting Training for {epochs} epochs...")
    for epoch in range(epochs):
        running_loss = 0.0
        for i, data in enumerate(trainloader, 0):
            inputs, labels = data
            inputs, labels = inputs.to(DEVICE), labels.to(DEVICE)

            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            if i % 100 == 99:
                print(f'[Epoch {epoch + 1}, Batch {i + 1}] loss: {running_loss / 100:.3f}')
                running_loss = 0.0
        scheduler.step()
    print("Training Finished.")

def run_experiment(use_bias=False):
    trainloader, testloader, classes = get_dataloaders(biased=use_bias)

    model = get_resnet_cifar()

    train_model(model, trainloader, epochs=EPOCHS)

    target_layer = model.layer4[-1].conv2
    grad_cam = GradCAM(model, target_layer)

    model.eval()
    dataiter = iter(testloader)
    images, labels = next(dataiter)
    images = images.to(DEVICE)

    print("\nGenerating Visualizations...")
    count = 0
    for i in range(len(labels)):
        current_label = labels[i].item()

        if use_bias:
            if current_label != 6: continue

        cam, pred_class = grad_cam.generate_cam(images[i].unsqueeze(0), current_label)

        label_name = classes[current_label]
        pred_name = classes[pred_class]

        print(f"True: {label_name}, Predicted: {pred_name}")
        show_cam_on_image(images[i], cam, title=f"Pred: {pred_name}")

        count += 1
        if count >= 3: break

if __name__ == "__main__":
    print("=======================================")
    print("STEP 1: RUNNING STANDARD EXPERIMENT")
    print("=======================================")
    run_experiment(use_bias=False)

    print("\n")
    print("=======================================")
    print("STEP 2: RUNNING BIASED EXPERIMENT")
    print("=======================================")
    run_experiment(use_bias=True)
